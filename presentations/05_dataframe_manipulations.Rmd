---
title: "Data analysis and visualization using R (1)"
author: "Michiel Noback"
date: "September 2019"
output:
  slidy_presentation: default
  ioslides_presentation: default
  pdf_document: default
  beamer_presentation: default
subtitle: Dataframe manipulations
job: lecturer at Hanze University of Applied Science
---


```{r setup, cache = F, echo = F, message = F, warning = F}
#comment out for pdf output
source("rmarkdown_knitr_header.R")
```

```{r echo = F}
par(mar=c(4, 4, 1.5, 0))
options(digits=4)
```

## Introduction

Dataframes are ubiquitous in R-based data analyses. Many R functions and packages are tailored specifically for DF manipulations - you have already seen `cbind()`, `rbind()` and `subset()`.  
In this presentation, we'll explore a few new functions and techniques for working with DFs:

- `apply()`
- `lapply()`
- `sapply()`
- `tapply()`
- `aggregate()`
- `split()`


# `apply()` and family


## The apply family of functions

Looping with `for` may be tempting, but highly discouraged in R because its inefficient. Ususally one of these functions will do it better:

- `apply`: Apply a function over the "margins" of a dataframe - rows or columns or both
- `lapply`: Loop over a list and evaluate a function on each element; returns a list of the same length
- `sapply`: Same as lapply but try to simplify the result
- `tapply`: Apply a function over subsets of a vector (read: split with a factor)
- (There are more but these are the important ones)

## Basic apply usage

- Suppose you want to know the means of all columns of a dataframe.
- `apply()` needs to know 
    1. what DF to apply to (`X`)
    2. over which margin(s) - columns and/or rows (`MARGIN`)
    3. what function to apply (`FUN`)

```{r apply_demo}
apply(X = cars, MARGIN = 2, FUN = mean) # apply over columns
```

## Both margins

Here, a function is applied to both columns and rows

```{r}
df <- data.frame(x = 1:5, y = 6:10)
apply(X = df, MARGIN = c(1,2), FUN = function(x) (x-1)^2)
```


## `apply()` example: BMI

- BMI is calculated as $(weight / height ^ 2) * 703$ where weight is in pounds and height in inches.

```{r apply_demo2}
head(women, n=3)
women$bmi <- apply(X = women, 
                   MARGIN = 1, 
                   FUN = function(x) (x[2] / x[1]^2) * 703)
head(women, n=4)
```

## Extract inline function

- When the passed inline function gets complicated it is advisable to extract it to a real function
    
```{r apply_demo3}
bmi <- function(height_weight) {
    (height_weight[2] / height_weight[1]^2) * 703
}
women$bmi <- apply(X = women, MARGIN = 1, FUN = bmi)
head(women, n=4)
```


## Pass arguments to the applied function

- Sometimes the applied function needs to have other arguments passed besides the row or column.
- The `...` argument to apply makes this possible (type ?apply to see more info)

```{r, results = "hold"}
# function sums and powers up
spwr <- function(x, p = 2) {sum(x)^p}
# a simple dataframe
df <- data.frame(a = 1:5, b = 6:10)
df
```

-----

```{r}
df
# spwr will use the default value for p (p = 2)
apply(X = df, MARGIN = 1, FUN = spwr) 
# pass power p = 3 to function spwr (argument names omitted)
apply(df, 1, spwr, p = 3) 
```


Note: The `...` argument works for all apply functions.

## `lapply()`: apply to a list

- `lapply()` applies a function to all elements of a list and returns a list with the same length, each element the result of applying the function

```{r lapply_demo1}
myNumbers = list(
    one = c(1, 3, 4), 
    two = c(3, 2, 6, 1), 
    three = c(5, 7, 6, 8, 9))
lapply(X = myNumbers, FUN = mean)
```


----

- Same, but with `sqrt()` applied
- Note how the nature of the applied function influences the result

```{r lapply_demo2}
lapply(X = myNumbers, FUN = sqrt)
```


## `sapply()`: apply to a list and try to simplify

- When using the same example as above, but with `sapply`, you get a vector returned
- Note that the resulting vector is a named vector

```{r sapply_demo}
myNumbers = list(
    one = c(1, 3, 4),
    two = c(3, 2, 6, 1),
    three = c(5, 7, 6, 8, 9))
sapply(X = myNumbers, FUN = mean)
```

## wasn't a dataframe also a list?

Yes! It is also list(ish). Both `lapply()` and `sapply()` work just fine on dataframes:

```{r df-is-also-list}
lapply(X = cars, FUN = mean)
sapply(X = cars, FUN = mean) 
```

By the way, sapply and lapply also work with vectors.

## `tapply()`: split and apply

- `tapply()`: Apply a function over subsets of a vector
- -> Split a vector into groups according to the levels in a second vector and apply the given function to each group

```{r tapply_demo}
tapply(X = chickwts$weight, INDEX = chickwts$feed, FUN = sd)
```


## `split()`: split into groups

- Use `split()` when a dataframe needs to be divided depending on the value of some grouping variable. The result is a list, with a member for each grouping value
- Here we have the response of Treated (T) and Untreated (UT) subjects

```{r split_demo1}
myData <- data.frame(
    response = c(5, 8, 4, 5, 9, 3, 6, 7, 3, 6, 5, 2),
    treatment = factor(
        c("UT", "T", "UT", "UT", "T", "UT", "T", "T", "UT", "T", "T", "UT")))
splData <- split(x = myData, f = myData$treatment)
str(splData)
```

----

```{r split_demo2, results = 'hold'}
## this trivial example could also have been done with
## boxplot(myData$response ~ myData$treatment)
boxplot(splData$T$response, splData$UT$response, 
        names = c("Treated", "Untreated"))
```

----

Note: split also works with vectors
```{r}
split(x = rnorm(10), f = rep(c("sick", "healthy"), each=5))
```

## `aggregate()`: Compute summary statistics of subsets

Splits the data into subsets, computes summary statistics for each, and returns the result in a convenient form.

```{r}
aggregate(formula = Temp ~ Month, data = airquality, FUN = mean)
```

## Two usages of `aggregate()`

Aggregate has two usages:  

- formula:  
  **`aggregate(formula, data, FUN, ...)`**  

- by:  
  **`aggregate(x, by, FUN, ...)`**  

I really like `aggregate()`, especially the first form. 

Both will be demonstrated

## Aggregate with formula

The left part of the formula accepts one, several or all columns as dependent variables.

```{r}
##two dependents
aggregate(cbind(Temp, Ozone) ~ Month, data = airquality, FUN = mean)
##all
aggregate(. ~ Month, data = airquality, FUN = mean)
```

----

The right part can also accept multiple independent variables


```{r}
airquality$Temp_factor <- cut(airquality$Temp, breaks = 2, labels = c("low", "high"))
aggregate(Ozone ~ Month + Temp_factor, data = airquality, FUN = mean)
```

## The `by = list(...)` form

This is the other form of aggregate. It is more elaborate in my opinion because you need te spell out all vectors you want to work on.

```{r}
aggregate(x = chickwts$weight, by = list(feed = chickwts$feed), FUN = mean)
```

-----

another example

```{r}
aggregate(x = airquality$Wind, 
          by = list(month = airquality$Month, temperature = airquality$Temp_factor), 
          FUN = mean)
```

better to wrap it in `with()`:


```{r eval=FALSE}
with(airquality, aggregate(x = Wind, 
                           by = list(month = Month, temperature = Temp_factor), 
                           FUN = mean))
```

## Many roads lead to Rome

The statements on the next slides are all essentially the same.
The message is: there is more than one way to do it!

```{r}
aggregate(weight ~ feed, data = chickwts, FUN = mean)
```

same as

```{r}
head(aggregate(x = chickwts$weight, by = list(feed = chickwts$feed), FUN = mean), n=3)
```

----


```{r message=FALSE}
tapply(chickwts$weight, chickwts$feed, mean)
with(chickwts, tapply(weight, feed, mean))
```

-----

```{r message=FALSE}
sapply(split(chickwts, chickwts$feed), function(x){mean(x$weight)})
library(dplyr)
group_by(chickwts, feed) %>% summarise(mean_weigth = mean(weight))
```

## `merge()` to bring data from two dataframes together

- In many cases, data is distributed over multiple sources (often files).
- The `merge()` function helps you combining these datasets on common identifiers.
- Suppose you want to analyse gene class in relation to expression levels
- Note that if two columns have the same name, `merge()` uses these by default!


----  

```{r}
gene.classes <- data.frame(
    geneID = c("gi:267", "gi:235", "gi:332", "gi:111"),
    class = c("regulator", "metabolism", "structural", "regulator"))
top.expressed.genes <- data.frame(
    tissue = c("connective", "muscle", "nervous", "epithelial"), 
    gene = c("gi:235", "gi:267", "gi:235", "gi:332"))
merge(top.expressed.genes, gene.classes, by.x="gene", by.y="geneID")
```

----

Consider the use of the `all = ` argument (`all`, `all.x` and `all.y`).

```{r}
merge(top.expressed.genes, gene.classes, by.x="gene", by.y="geneID", all=TRUE)

```

